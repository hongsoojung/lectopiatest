객체지향언어

class Human

Human h = new Hnuma();

h - 객체형변수(객체),인스턴스

캡슐화하는 이유 - 캡슐 내부와 외부를 구분하기 위해
		- 내부의 무언가(속성이든 행위이든)를 
 		  숨기려고 캡슐화를 한다.(정보의 은닉)

캡슐화는 클래스를 통해서 이루어진다.
ex) Human class{
	int age;
	public void sleep(){}
}

이렇게 다 은닉하면 캡슐 내부와 외부가 의사소통이 안되므로
특정행위(멤버함수)를 공개 시키는 것을 인터페이스!
인터페이스 - 메시지를 주고 받을 수 있다.
	     입출력,(내부와 외부 의사소통)

정보의 은닉 - 캡슐안의 무엇을 숨김
	      접근 제한자 ex) public, protected,private,package
	      에 의해서 은닉이 된다.

외부에 공개된 것 보다 내부에 숨겨 진게 많으면 '추상화 정도'가 높다.
추상화 정도가 높아지면 내부 알고리즘을 쉽게 수정 할 수 있다.
(유지보수성이 높아진다.)

상속: Is-A 관계(하위에서 상위 ex-기사는 캐릭터다)
      재사용성의 향상

================================================================
***다형성***
: 주어진 조건에 따라 다른 행위를 일으킨다.
ex) 오버로딩 1. 동일한 클래스내에 동일한 식별자(함수명)를 갖는 		행위가 여러개 존재
		ex) public void sleep();
		    public void sleep(args_list);
		매개변수의 형태를 이용해서 어떤 메소드를 실행 
		할지 결정.
		식별자(함수명)+전달인자 = 시그니쳐

	     2. 상속관계에서 부모클래스의 행위를 자식클래스에서 
		구현하는 것
		ex) character c = new Knight();
		c는 character의 객체지만 knight의 인스턴스	
		c.fight()를 하게되면 승인은 character에서 승인을 		하지만 실행은 kight의 fight()가 실행된다.
전체적으로 묶어서 오버라이딩이라고 하지만
재정의가 목적이 아니면 오버로딩이라고 명확하
게 해야한다.

		




